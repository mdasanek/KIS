<!DOCTYPE html><!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Sun Jan 04 2026 14:16:50 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="690b2ae197081010cb33c3fd" data-wf-site="654e3c7ec4958a4139c16269" lang="en">
<head>
  <meta charset="utf-8">
  <title>prototype 2</title>
  <meta content="prototype 2" property="og:title">
  <meta content="prototype 2" property="twitter:title">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/kissss.webflow.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Inter Tight:100,200,300,regular,500,600,700,800,900:cyrillic,latin"]  }});</script>
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.png" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
  <style>
  /* === ГЛОБАЛЬНЫЙ СЛОЙ ДЛЯ СТИКЕРОВ === */
  .stickers-stage {
    position: fixed;       /* фиксируем слой на весь экран */
    inset: 0;              /* растянуть от края до края */
    z-index: 0;            /* под контентом, можешь увеличить до 100 если хочешь поверх */
    overflow: visible;     /* можно утаскивать за края */
    pointer-events: none;  /* слой не ловит клики */
  }
  /* === СТИКЕР === */
  .sticker {
    position: absolute;
    pointer-events: auto;  /* клики включены только у стикеров */
    cursor: grab;
    user-select: none;
    -webkit-user-drag: none;
    touch-action: none;    /* чтобы не скроллило при перетаскивании */
    will-change: transform; /* двигаем через transform */
    transition: filter 180ms ease;
  }
  .sticker.dragging {
    cursor: grabbing;
  }
  /* Подстраховка: отключить горизонтальный скролл на всякий случай */
  html, body {
    overflow-x: clip; /* (или hidden, если clip не поддерживается) */
  }
</style>
</head>
<body>
  <section class="stickers-stage"><img src="images/AVATAR.webp" loading="lazy" data-id="s1" alt="" class="sticker"></section>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=654e3c7ec4958a4139c16269" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  <script>
(function(){
  const STORAGE_KEY = 'stickers-pos-inertia-v1';
  const LERP = 0.25;  // коэффициент сглаживания (0.1–0.3 = плавнее, 1 = без инерции)
  const FPS = 60;     // частота обновления
  const stage = document.querySelector('.stickers-stage');
  if(!stage) return;
  let zCounter = 1000;
  const saved = loadPositions();
  const stickers = Array.from(stage.querySelectorAll('.sticker'));
  stickers.forEach(initSticker);
  function initSticker(el){
    const id = el.getAttribute('data-id') || (el.id || makeId());
    el.setAttribute('data-id', id);
    const pos = saved[id] || { tx: 0, ty: 0 };
    const state = {
      tx: pos.tx, ty: pos.ty,       // фактическая позиция
      targetTx: pos.tx, targetTy: pos.ty, // цель
      dragging: false
    };
    el.__state = state;
    setTranslate(el, state.tx, state.ty);
    el.addEventListener('pointerdown', e => onPointerDown(e, el));
    requestAnimationFrame(() => animateSticker(el));
  }
  function onPointerDown(e, el){
    const s = el.__state;
    s.dragging = true;
    el.setPointerCapture(e.pointerId);
    el.classList.add('dragging');
    el.style.zIndex = (++zCounter).toString();
    const start = {
      x: e.clientX,
      y: e.clientY,
      baseTx: s.targetTx,
      baseTy: s.targetTy
    };
    function onMove(ev){
      const dx = ev.clientX - start.x;
      const dy = ev.clientY - start.y;
      s.targetTx = start.baseTx + dx;
      s.targetTy = start.baseTy + dy;
    }
    function onUp(ev){
      s.dragging = false;
      el.releasePointerCapture(ev.pointerId);
      el.classList.remove('dragging');
      el.removeEventListener('pointermove', onMove);
      el.removeEventListener('pointerup', onUp);
      el.removeEventListener('pointercancel', onUp);
      // сохраняем
      const id = el.getAttribute('data-id');
      const all = loadPositions();
      all[id] = { tx: s.targetTx, ty: s.targetTy };
      savePositions(all);
    }
    el.addEventListener('pointermove', onMove);
    el.addEventListener('pointerup', onUp);
    el.addEventListener('pointercancel', onUp);
  }
  function animateSticker(el){
    const s = el.__state;
    if(!s) return;
    // приближаем текущую позицию к целевой
    s.tx += (s.targetTx - s.tx) * LERP;
    s.ty += (s.targetTy - s.ty) * LERP;
    // если разница совсем маленькая — можно считать достигнуто
    if (Math.abs(s.targetTx - s.tx) < 0.01) s.tx = s.targetTx;
    if (Math.abs(s.targetTy - s.ty) < 0.01) s.ty = s.targetTy;
    setTranslate(el, s.tx, s.ty);
    // рендерим на каждом кадре
    setTimeout(() => requestAnimationFrame(() => animateSticker(el)), 1000 / FPS);
  }
  /* === Вспомогательные функции === */
  function setTranslate(el, tx, ty){
    el.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
  }
  function loadPositions(){
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }
    catch{ return {}; }
  }
  function savePositions(obj){
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); }
    catch{}
  }
  function makeId(){
    return 's_' + (crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
  }
})();
</script>
</body>
</html>